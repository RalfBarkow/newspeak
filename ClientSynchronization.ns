Newspeak3
'OrthogonalSynchronization'
class ClientSynchronization usingPlatform: platform clientServer: clientServerModule manifest: manifest = (
|
	manifest = manifest.
	private Smalltalk = 	platform squeak Smalltalk.
	WeakIdentityKeyMap = platform squeak WeakIdentityKeyDictionary.
	Map = platform collections Map. 
	IdentityMap = platform collections IdentityMap.
	
	Set = platform collections Set. 
	IdentitySet = platform collections IdentitySet.
		
	ObjectMirror = platform mirrors ObjectMirror.
	clientServerSync = clientServerModule.
|
) (
class ChangeAnalyzerResult newIds: newIdsMap changeLog: aChangeLogForServer = (
|
	public newObjectToLocalIds = newIdsMap.
	public changeLog = aChangeLogForServer.
	
|
) (
public hasNoChanges = (
	^ changeLog hasNoChanges.
)
) : (
)
public class ChangeTrackingContext = (
|
	guidByObject = WeakIdentityKeyMap new.
	stateByObject = WeakIdentityKeyMap new.
|
) (
class ChangeAnalyzer = (
|
	newObjectsIds
|
) (
changesForExistingObjects = (
	^ Array streamContents: [:stm |
		existingObjectAndStateDo: [:object :state |
			createChangeRecordFor: object
			 withState: state
			 ifNeeded:  [:changeRecord | stm nextPut: changeRecord] .
		].
	].	
)
computeNewObjectDefinitionsDo: definitionsAndIdsMapBlock  = (
	| objectToLocalIdMap newDefinitions |
	objectToLocalIdMap:: Map new.

	newDefinitions:: Array streamContents: [:stm |
		newObjectsIds keysDo: [ :newObject  |

			| definitionWithId |
			definitionWithId::  (createObjectDefinitionWithIdFor: newObject).
			objectToLocalIdMap at: newObject put: definitionWithId id.
			stm nextPut: definitionWithId.
		].
	].	

	definitionsAndIdsMapBlock value: newDefinitions value: objectToLocalIdMap.
)
context  = (

	^ (ObjectMirror reflecting: self) getClass enclosingObject reflectee
)
createChangeRecordFor: anObject withState: initialState ifNeeded: newChangeRecordBlock = (	

	anObject isArray 
					ifTrue:  [ createChangeRecordForArray: anObject withState: initialState ifNeeded: newChangeRecordBlock]
					ifFalse: [ createChangeRecordForRegularObject: anObject withState: initialState ifNeeded: newChangeRecordBlock ].
	
)
createChangeRecordForArray: anObject withState: initialState ifNeeded: newChangeRecordBlock    = (
	| changesByIndex  |

	changesByIndex:: Map new.
	1 to: anObject size do:  [ :index |
		| content reference |
		content:: anObject at: index.
		reference:: initialState at: index.
		(reference refersTo: content inContext: context) ifFalse: 
			[ changesByIndex at: index put:  (toObjectReference: content)   ].
	].


	changesByIndex isEmpty 
		ifFalse:  [ 
				| ch |
				ch:: ArrayChange withChanges: changesByIndex.
				newChangeRecordBlock value: ( ObjectChangeRecord 
													for: (toExistingObjectReference: anObject) 
													withChange: ch). ]. 


)
createChangeRecordForRegularObject: anObject withState: initialState ifNeeded: newChangeRecordBlock  = (
	| changesBySlot mirror |
	mirror:: ObjectMirror reflecting: anObject.	
	changesBySlot:: Map new.
	initialState keysAndValuesDo: [ :selector :val |
		| slotContent  |
		slotContent:: (mirror getSlot: selector) reflectee. 
		(val refersTo: slotContent inContext:  context topLevel: manifest) ifFalse: [ 
			changesBySlot at: selector put:  (toObjectReference: slotContent)  
		].
	].

	changesBySlot isEmpty 
		ifFalse:  [ 	
				| ch |
				ch:: RegularObjectChange withChanges: changesBySlot.
				
				newChangeRecordBlock value: (ObjectChangeRecord 
													for: (toExistingObjectReference: anObject) 
													withChange: ch). ] 

	 
)
createObjectDefinitionFor: anObject   = (	


	anObject isBlock ifTrue: [ error].
	
	anObject isBehavior ifTrue: 
		[ ^ anObject isMeta 	
					ifTrue: [error] 
					ifFalse: [ createObjectDefinitionForClass: anObject  ]].
	
	anObject isArray ifTrue: 
		[ ^ createObjectDefinitionForArray: anObject ].
	
	^ createObjectDefinitionForRegularObject: anObject
	
	
	

)
createObjectDefinitionForArray: anObject   = (	
	|  values  |
	values:: createObjectStateFor: anObject.
	^ ArrayDefinition withContents: values.
)
createObjectDefinitionForClass: anObject   = (	
	|  mirror enclosingObject mixin superclass   |
	
	mirror:: objectMirrorFor: anObject.
	
	enclosingObject:: (mirror getSlot: #enclosingObjectSlot) reflectee.
	
	superclass:: (mirror getSlot: #superclass) reflectee.
	(superclass == Object) 
		ifTrue: [ superclass:: nil.] .
	
	mixin:: (mirror getSlot: #mixinSlot) reflectee.

	^ ClassDefinition  
		mixin: (toObjectReference: mixin)
		superclass: (toObjectReference: superclass) 
		enclosingObjectReference: (toObjectReference: enclosingObject)
	
)
createObjectDefinitionForRegularObject: anObject   = (	
	|  klass valuesBySlot  |
	
	valuesBySlot:: createObjectStateFor: anObject.
	klass:: clientServerSync classFor: anObject.
	 
	^ ObjectDefinition 
		classReference: (toObjectReference: klass)  
		withContents: valuesBySlot.
		

)
createObjectDefinitionWithIdFor: anObject   = (	
	|     newId   |
	newId:: newObjectsIds at: anObject.
	^ ObjectDefinitionWithIdentification id: newId definition: (createObjectDefinitionFor: anObject).  
)
createObjectStateFor: anObject  = (
	^ createObjectState: anObject newObjectFrom: [ :obj | newObjectReferenceFor: obj ]
)
discoverNewObjects = (
	traverseObjectsGraph: newObjectsIds keys visited: (IdentitySet withAll:  existingObjects)  do: [ :each |
	
		(isNew: each) ifTrue: [
			registerIdForNewObjectIfNeeded: each.
		].
	].
)
idForNewObject: anObject  = (
	registerIdForNewObjectIfNeeded: anObject.
	^ newObjectsIds at: anObject.
)
isTraversable: anObject = (
	^(isIdentifiable: anObject) or: [ anObject isBehavior and: [ anObject ~= Array] ]
)
newObjectReferenceFor: anObject = (
	^ toNewObjectReferenceIdentifiedWith: (idForNewObject: anObject).
)
registerIdForNewObjectIfNeeded: anObject  = (
	| newId  existingIds |
	newId:: 1.
	existingIds:: newObjectsIds values.
	existingIds isEmpty ifFalse: [
		newId:: existingIds max + 1.
	].	
	
	^ newObjectsIds at: anObject ifAbsentPut: [ newId ].
)
toObjectReference: anObject = (
	^ toObjectReference: anObject newObjectFrom: [ :obj | newObjectReferenceFor: obj ] .	
)
traverseObjectsGraph: elements visited: visitedObjects do: aBlock = (

	(elements select: [:x | isTraversable: x]) do: [ :each |
		(visitedObjects includes: each) ifFalse: [
			visitedObjects add: each.
			aBlock value:  each. 
		
			(* slotsIn: each do: [:selector :content |  *)		
			linkedObjectsFor:  each do: [ :content |
				(* discovered: content.  *)
	 			traverseObjectsGraph: {content} visited: visitedObjects do: aBlock.		
			].
			
		].	
	].
)
public value  = (
	| detectedChanges  changeLog   |

	newObjectsIds:: IdentityMap new.

	detectedChanges:: changesForExistingObjects.
	(* halt. *) 
	discoverNewObjects. 
	computeNewObjectDefinitionsDo:
	 [ 
		:newObjectDefinitions :newObjectToLocalMap |
		changeLog:: ClientToServerChangeLog 
						withChanges: detectedChanges 
						withNewObjects: newObjectDefinitions.
						
		^ ChangeAnalyzerResult newIds: newObjectToLocalMap changeLog: changeLog. ].
)
) : (
)
class ObjectState className: aClassName enclosing: anEnclosingObject  contents: contents  = (
|
	public className = aClassName.
	public slotContents = contents.
	public enclosingObject = enclosingObject.
|
) (
) : (
)
createArrayState: anArray  newObjectFrom: newObjectBlock = (
	^ (anArray collect: 
		 [ :each |  toObjectReference: each  newObjectFrom: newObjectBlock  ]) asArray.
)
createClassState: aClass newObjectFrom: newObjectBlock = (
	|  valuesBySelector    selectorsToSave |
	
	selectorsToSave:: { #superclass . #mixinSlot . #enclosingObjectSlot }.
	valuesBySelector:: Map new.
	
	slotsIn: aClass do:  [ :selector :content |
		(selectorsToSave includes: selector) ifTrue: [
			| objectReference enclosingObjectReference |
			objectReference:: toObjectReference: content newObjectFrom: newObjectBlock .
			valuesBySelector at: selector put: objectReference.
		].
	].

	^ valuesBySelector		
			
)
createObjectState: anObject  = (
	^ createObjectState: anObject newObjectFrom: nil.
)
createObjectState: anObject newObjectFrom: newObjectBlock  = (
	
	anObject isBlock ifTrue: [ error].
	
	anObject isBehavior ifTrue: 
		[ ^ anObject isMeta 	
					ifTrue: [error] 
					ifFalse: [ createClassState: anObject newObjectFrom: newObjectBlock ]].
	
	anObject isArray ifTrue: 
		[ ^ createArrayState: anObject newObjectFrom: newObjectBlock ].
	
	^ createRegularObjectState: anObject newObjectFrom: newObjectBlock
)
createRegularObjectState: anObject newObjectFrom: newObjectBlock = (
	|  valuesBySelector    |
	valuesBySelector:: Map new.
	
	slotsIn: anObject do:  [ :selector :content |
		| objectReference |
		objectReference:: toObjectReference: content newObjectFrom: newObjectBlock .
		valuesBySelector at: selector put: objectReference.
	].

	^ valuesBySelector		
			
)
public detectChanges = (
	garbageCollect. 
	^ ChangeAnalyzer new value.
)
existingObjectAndStateDo: aBlock = (
	stateByObject keysAndValuesDo: aBlock.
)
public existingObjects  = (
	^ guidByObject keys	
)
guidFor: anObject  = (
	^ guidByObject at: anObject.
)
public idForObject: anObject  = (
	^ guidByObject at: anObject.
)
public installImmutableObjectsFromIObjectToIdsMap: anIdsMap = (
	| allObjects |
		
	allObjects:: anIdsMap keys.
	allObjects do: [:each | guidByObject at: each put: (anIdsMap at: each) ].
)
public installNewObjectsFromIObjectToIdsMap: anIdsMap = (
	| allObjects |
		
	allObjects:: anIdsMap keys.
	allObjects do: [:each | guidByObject at: each put: (anIdsMap at: each) ].
	allObjects do: [:each | saveObjectState: each. ].
)
internalSlotNameForNestedClassNamed: className = (
	^ 	className,  '`slot'
)
public isIdentifiable: anObject  = (
	anObject isBlock ifTrue: [ error].
	
	(* .  #isBehavior *)
	
	^ ({ #isKindOfInteger . #isKindOfString  . #isNil   } 
		anySatisfy:  [:selector | anObject perform:  selector ] ) not

)
isNew: anObject = (
		anObject isBlock ifTrue: [ error].
	

	^ ((isIdentifiable: anObject) and:
		[ (isTracked: anObject) not ]) and: [ (isNotSynchronizable: anObject) not]
)
isNotSynchronizable: anObject =   (
	((guidByObject includesKey: anObject) and: [ (stateByObject includesKey: anObject) not ]) 
		ifTrue: [^true].
	
	((anObject isBehavior) and: [ isNotSynchronizable: (clientServerSync enclosingObjectFor: anObject)  ]) ifTrue: [
		^ true
	].

	^false

)
public isTracked: anObject = (
	^ guidByObject includesKey: anObject.
)
public isTrackingObjectWithId: anId  = (
	objectById: anId ifNotFound: [ ^ false].
	^ true.
)
linkedObjectsFor:  anObject do: aBlock	 = (
	
	anObject isBlock ifTrue: [ error].
	

	anObject isBehavior ifTrue: 
		[ ^linkedObjectsForClass:  anObject do: aBlock ]. 
	
	
	anObject isArray ifTrue: 
		[ ^linkedObjectsForArray:  anObject do: aBlock ].
	
	^ linkedObjectsForRegularObject:  anObject do: aBlock. 

)
linkedObjectsForArray:  anObject do: aBlock	 = (
	anObject do: aBlock. 
)
linkedObjectsForClass:  anObject do: aBlock	 = (
	aBlock value: (clientServerSync enclosingObjectFor: anObject). 
)
linkedObjectsForRegularObject:  anObject do: aBlock	 = (
	slotsIn: anObject do:  [ :selector :content | aBlock value: content ].
	aBlock value: (clientServerSync classFor: anObject). 
	
	
)
public objectById: anIdentifier = (
	^  objectById: anIdentifier ifNotFound: [ error].
)
public objectById: anIdentifier ifNotFound: notFoundBlock = (
	guidByObject keysAndValuesDo: [ :object :id | 
		(id = anIdentifier) ifTrue: [ ^ object].
	].

	^ notFoundBlock value.	
)
objectMirrorFor: anObject  = (
	^ObjectMirror reflecting: anObject.
)
public objectWithGuid: anIdentifier = (
	^  objectById: anIdentifier.
)
public objectsDo: aBlock = (
	guidByObject keys do: aBlock.
)
saveObjectState: anObject  = (
	stateByObject at: anObject put: (createObjectState: anObject).
)
slotsIn: anObject do: selectorAndContentBlock = (
	| mirror valuesBySelector |
	
	mirror:: ObjectMirror reflecting: anObject.
	
	(* regular slots *)
	mirror getClass slots do:  [ :each |
		| selector  object|
		anObject isKindOfArray ifTrue:   [halt].
		selector:: each name.
		object:: (mirror getSlot: selector) reflectee.
		selectorAndContentBlock value: selector value: object.
	].


	(* nested classes' slots *)
	mirror getClass nestedClasses do:  [ :each |
		| selector  object|
		anObject isKindOfArray ifTrue:   [halt].
		selector:: internalSlotNameForNestedClassNamed: each name. 
		object:: (mirror getSlot: selector) reflectee.
		selectorAndContentBlock value: selector value: object.
	].
)
toExistingObjectReference: anObject = (
	^ toObjectReference: anObject newObjectFrom: [:x | error]. 
)
toNewObjectReferenceIdentifiedWith: id  = (
	^  NewObjectReference toObjectIdentifiedWith: id.
)
toObjectReference: anObject newObjectFrom: newObjectBlock = (

(*	(anObject isBehavior and: [ ((anObject printString  = 'Object') or: [ anObject printString = 'Array'])]) ifTrue: [ 
		^toObjectReferenceForReserved: anObject	
	].
*)
(*	(anObject isKindOfMixin) ifTrue: [ halt ]. *)

	
	((anObject isBehavior) and: [ isNotSynchronizable: (clientServerSync enclosingObjectFor: anObject)  ]) ifTrue: [
		^toObjectReferenceByMessageSendForClass: anObject newObjectFrom: newObjectBlock
	].


	^ (isIdentifiable:  anObject) 
		ifTrue: [ 
			(isNew: anObject) 
				ifTrue: [ newObjectBlock value: anObject ]
				ifFalse: [ ObjectReference toObjectIdentifiedWith: (guidFor: anObject) ]]
		ifFalse: [ UnidentifiableObject for: anObject ].
)
toObjectReferenceByMessageSendForClass: aClass newObjectFrom: newObjectBlock = (
	| enclosingObject |
	enclosingObject:: clientServerSync enclosingObjectFor: aClass.
	^ ObjectReferenceByMessageSend 
		receiverReference: (toObjectReference: enclosingObject newObjectFrom: newObjectBlock) 
		selector: (clientServerSync mixinNameForClass:  aClass).
	
)
toObjectReferenceForReserved: aClass = (
	halt.
	^ ObjectReferenceByMessageSend 
		receiverReference: (UnidentifiableObject for: nil) 
		selector: aClass printString.
	
)
public updateStateForObjectsWithId: ids =  (

	ids do: [ :each | saveObjectState: (objectById: each)  ].
)
) : (
)
public class ClientUpdater materializingObjectsWith: aMaterializerFactory forContext: cto endPoint: anEndPoint= (
|
	changeTrackingContext = cto.
	endPoint = anEndPoint.
	materializerFactory = aMaterializerFactory.
|
) (
applyChangesFrom:  changeRecords in: aStore = (
	changeRecords do: [ :each | each applyChangesIn: aStore usingMirror: ObjectMirror ].   
)
applyClientChangesFrom:  changeRecords in: aStore = (
	
	| storeVersion |
	storeVersion:: changeTrackingContext. 
	
	changeRecords do: [ :each | 
		| globalChangeRecord  previousVersion   |
		
		globalChangeRecord:: each asGlobalReferenceUsing: aStore. 
		previousVersion:: storeVersion singleParentVersion versionById: globalChangeRecord objectReference identifier.
		 storeVersion addObjectVersionWithParent: previousVersion versionedData: globalChangeRecord change.

	].   
)
createStoreForGlobalNewObjects = (
	^ ObjectStoreWithGlobalNewObjects forContext: changeTrackingContext.
)
createStoreForLocalNewObjects = (
	^ ObjectStoreWithLocalNewObjects forStoreVersion: changeTrackingContext newGuidBlock: [ endPoint generateNextGuid ].
)
installLocalObjectsWithGuidUsing: clientChangesResult mappingGlobalsWith: serverToClientChangeLog  = (
	| objectToIdMap | 

	objectToIdMap:: Map new.
	clientChangesResult ifNotNil: [
		clientChangesResult newObjectToLocalIds keysAndValuesDo: [ :object :localId |
			  (serverToClientChangeLog  localToGlobalIds includesKey: localId) 
				ifTrue:  [ objectToIdMap at: object put: (serverToClientChangeLog  localToGlobalIds at: localId)   ].
		].
	].
	changeTrackingContext installNewObjectsFromIObjectToIdsMap: objectToIdMap.
)
installNewObjectsFromDefinitions:  objectDefinitionsWithId usingStore: aStore  = (
	| materializer |
	materializer:: materializerFactory value: aStore. 
	materializer materializeObjectsFrom: objectDefinitionsWithId.
	 (* aStore registerNewObjects. *)
)
public updateFrom: clientChangesResult to: serverToClientChangeLog  = (
	| store |

	installLocalObjectsWithGuidUsing: clientChangesResult mappingGlobalsWith: serverToClientChangeLog.

	store:: createStoreForGlobalNewObjects.
	installNewObjectsFromDefinitions: serverToClientChangeLog newObjects usingStore: store. 
	applyChangesFrom:  serverToClientChangeLog changeRecords in: store.  
	store registerNewObjects.
	
	clientChangesResult ifNotNil: [
		store updateStateForObjectsWithId: ( clientChangesResult changeLog changeRecords 
												collect: [ :x | x objectReference identifier] ).	
	]. 
	store updateStateForObjectsWithId: ( serverToClientChangeLog  changeRecords collect: [ :x | x objectReference identifier] ).	


	^ serverToClientChangeLog rootObjectReference referencedObjectFrom: store topLevel: nil.
	
	
)
public updateServerFrom: clientToServerChangeLog = (
	| store  |

	store:: createStoreForLocalNewObjects.
	installNewObjectsFromDefinitions: clientToServerChangeLog newObjectsDefinitions usingStore: store. 
	store registerNewObjects.
	applyClientChangesFrom:  clientToServerChangeLog changeRecords in: store.  
	^ store localToGuidMap
	
)
) : (
)
class DefinitionsToObjectsMaterializer objectStore: aStore manifest: aManifest  = ObjectsMaterializer objectStore: aStore (
|
	manifest = aManifest.
|
) (
createInstanceFrom: definitionWithId = (

	^ definitionWithId definition createEmptyInstanceUsingContext: objectStore topLevel: manifest.
)
fillNewInstance: anInstance fromDefinition: aDefinition = (
	| newInstanceMirror |

	newInstanceMirror:: ObjectMirror reflecting: anInstance.
	aDefinition  fill: newInstanceMirror resolvingReferencesWith: objectStore topLevel: manifest. 
)
) : (
)
public class InMemoryStoreBroker store: aStore = (
|

 	store = aStore.
|
	
) (
public atAnchorVersion = (
	^ store anchorVersion
)
public currentAnchorId = (
	^ store anchorVersionId.
)
public initialUpdate  = (
	^ store retrieveCurrentStateChangeLog.
)
public initialUpdateAtVersion: aVersionNumber  = (
	^ store retrieveStateChangeLogAtVersionId: aVersionNumber.
)
public newClient = (
	| client |
	client:: StoreClient server: self.
	client synchronize.
	^client
)
public pushChanges: aChangeLogFromClient = (
	^ store pushChanges: aChangeLogFromClient.

)
public synchronize: aChangeLogFromClient = (
	^ store synchronizeFromChangeLog: aChangeLogFromClient.

)
) : (
)
class ObjectStoreWithGlobalNewObjects forContext: aTrackingContext  = TransientObjectStore  (
|
	changeTrackingContext = aTrackingContext.
	newObjectsByGuid = Map new.
|
) (
public containsNewObjectWithId: anId  = (
	^  newObjectsByGuid includesKey: anId.
)
public containsObjectWithGuid: anIdentifier = (
	changeTrackingContext objectById: anIdentifier ifNotFound: [
		^ newObjectsByGuid includesKey: anIdentifier.
	].

	^ true 
)
public newObjectWithId: anId  = (
	^  newObjectsByGuid at: anId.

)
public newObjects  = (
	^  newObjectsByGuid values

)
public objectWithGuid: anIdentifier = (
	^ changeTrackingContext objectById: anIdentifier ifNotFound: [
		newObjectsByGuid at: anIdentifier.
	]. 
)
public registerNewObjects = (
	changeTrackingContext installNewObjectsFromIObjectToIdsMap: (reverseLookup: newObjectsByGuid). 
)
public registerObject: anObject identifiedWith: id = (
 	newObjectsByGuid at: id put: anObject.
)
public updateStateForObjectsWithId: ids = (
	changeTrackingContext updateStateForObjectsWithId: ids.
)
) : (
)
class ObjectStoreWithLocalNewObjects forStoreVersion: aStoreVersion newGuidBlock: aNewGuidBlock = TransientObjectStore  (
|
	storeVersion = aStoreVersion.
	newObjectsByLocal = Map new.
	newGuidBlock = aNewGuidBlock.
|
) (
public containsNewObjectWithId: anId  = (
	^ newObjectsByLocal includesKey: anId.

)
public containsObjectWithGuid: anIdentifier = (
	storeVersion objectById: anIdentifier ifNotFound: [
		^ false.
	].
	^true 
)
public guidForLocal: aLocalId = (
	^ (newObjectsByLocal at: aLocalId) principalId.
	(* ^ localToGuidMap at: aLocalId. *)
)
public localToGuidMap = (
	| newMap |
	newMap:: Map new.
	newObjectsByLocal keysAndValuesDo: [ :localId :object | newMap at: localId put: object principalId   ].	

	^ newMap
)
public newGuid = (
	^ newGuidBlock value.
)
public newObjectWithId: anId  = (
	^  newObjectsByLocal at: anId.

)
public newObjects  = (
	^  newObjectsByLocal values

)
public objectWithGuid: anIdentifier = (
	^ storeVersion versionById: anIdentifier .
)
public registerNewObjects = (

	newObjectsByLocal values do: [ :object  | storeVersion addObjectVersion:  object .  ].
	
)
public registerObject: anObject identifiedWith: id = (
 	newObjectsByLocal at: id put: anObject.
)
) : (
)
public class ObjectsMaterializer objectStore: anObjectStore = (
|
	objectStore = anObjectStore.
	initializedIds = Set new.
|
) (
createInstanceFrom:   definitionWithId = (
	subclassResponsibility.

)
ensureMaterialized: ids usingDefinitions: definitionsWithId = (
	|   definitionsToIniitialize |

	(* ensure every new object  gets instantiated (empty) but with an id *)
	ids do: [:each | registerIfNeededObjectWithId:  each usingDefinitions: definitionsWithId ].
	
	definitionsToIniitialize:: (definitionsWithId select: [ :each |  ids includes: each id  ]) 
							reject: [ :each | initializedIds includes: each id ].

	definitionsToIniitialize collect: [:eachDef | 
			| newInstance  |
			
			
			eachDef definition withDependentObjectReferencesByIdDo: [ :eachRef :eachId |
				(eachRef existsReferencedObjectIn: objectStore) ifFalse: [
					(eachId >= 0) ifTrue: [ (* PATCH: negative ids are for 'well know objects' that should not be synchronized  *)
						ensureMaterialized: {eachId } usingDefinitions: definitionsWithId.				
					].
				].
				
			]. 
			
		
			newInstance:: objectStore newObjectWithId: eachDef id .  
			fillNewInstance: newInstance fromDefinition: eachDef definition.
			initializedIds add: eachDef id.
	].

	
)
fillNewInstance: anInstance fromDefinition: aDefinition = (
	subclassResponsibility.
)
public materializeObjectsFrom: definitionsWithId = (

	ensureMaterialized: (definitionsWithId collect: [:each | each id ])  usingDefinitions: definitionsWithId.
	(self class printString includesSubstring: 'Version') ifTrue: [objectStore newObjects do: [ :x  | x versionedData ifNil: [halt]]].
	^objectStore newObjects.

)
registerIfNeededObjectWithId: anId usingDefinitions: definitions = (

	
	(objectStore containsNewObjectWithId: anId) ifFalse: [
		| definitionWithId definition newInstance newDependingRefs  |
		definitionWithId:: definitions detect: [:each | each id = anId  ].
		definition:: definitionWithId definition.
		
		newDependingRefs:: Set new.
		
		definition withDependentObjectReferencesByIdDo: [ :eachRef :eachId |
			(eachRef existsReferencedObjectIn: objectStore) ifFalse: [
				(eachId >= 0) ifTrue: [ (* PATCH: negative ids are for 'well know objects' that should not be synchronized  *)
					registerIfNeededObjectWithId: eachId  usingDefinitions: definitions.
					newDependingRefs add: eachRef.
				].
			].
				
		]. 
		
	
		definition withDependentInitializedObjectReferencesByIdDo: [ :eachRef :eachId |
			(newDependingRefs includes: eachRef)  ifTrue: [
				ensureMaterialized: eachId usingDefinitions: definitions.
			].	
		].		
	
		
		newInstance:: createInstanceFrom: definitionWithId. 
		objectStore registerObject: newInstance identifiedWith: definitionWithId id.	
	
	].
)
) : (
)
public class StoreClient  server: aServer  = (
|
	server = aServer.
	public root
	public cto
	public currentVersion

|
	reset.
) (
public checkoutVersion: aVersionNumber   = (
	|  serverResponse  |

	reset.
	serverResponse:: server initialUpdateAtVersion: aVersionNumber.
	updateLocalUsingDetectedChanges: nil serverResponse: serverResponse.
)
createClientUpdater = (
	^ ClientUpdater materializingObjectsWith: [ :aStore |  DefinitionsToObjectsMaterializer objectStore: aStore manifest: manifest  ] forContext: cto endPoint: nil.
)
ensureIsInitialized = (
	currentVersion ifNil: [ error: 'client not initialozed'].
)
public hasPendingChanges = (
	^ cto detectChanges hasNoChanges not.
)
public idForObject: anObject = (
	^ cto idForObject: anObject
)
public isTracked: anObject = (
	^ cto isTracked: anObject
)
public objectById: anId = (
	 ^ cto objectById: anId.
)
private pushChanges  = (
	| detectedChanges serverResponse  |
	
	ensureIsInitialized. 

	detectedChanges:: cto detectChanges.
	detectedChanges changeLog versionId: currentVersion.
	serverResponse:: server pushChanges: detectedChanges changeLog.
	updateLocalUsingDetectedChanges: detectedChanges serverResponse: serverResponse.
	
)
public reset = ( 
	cto:: ChangeTrackingContext new. 
	currentVersion:: 0.
	root:: nil.

)
resetTransientSlots = (
	cto objectsDo: [ :anObject |
		| objectMirror| 
		objectMirror:: ObjectMirror reflecting: anObject.
		objectMirror getClass transientSlots do: [ :aSlot |  objectMirror setTransientSlot: aSlot name to: nil   ] 
	].
)
public synchronize  = (
	| detectedChanges serverResponse  |
	detectedChanges:: nil.

	root ifNil: [
		serverResponse:: server initialUpdate.
	] 
	ifNotNil: [
		detectedChanges:: cto detectChanges.
		detectedChanges changeLog versionId: currentVersion.
		serverResponse:: server synchronize: detectedChanges changeLog.
	].	
	updateLocalUsingDetectedChanges: detectedChanges serverResponse: serverResponse.	
)
updateLocalUsingDetectedChanges: detectedChanges serverResponse: serverResponse = (
	|   clientUpdater |

	clientUpdater::  createClientUpdater.
	root:: clientUpdater updateFrom: detectedChanges to: serverResponse.
	resetTransientSlots.
	currentVersion:: serverResponse versionId.
)
) : (
)
class TransientObjectStore    = (
|
|	
) (
public containsNewObjectWithId: anId  = (
	subclassResponsibility
)
public containsObjectWithGuid: anIdentifier = (
	subclassResponsibility
)
public newObjectWithId: anId  = (
	subclassResponsibility
)
public objectWithGuid: anIdentifier = (
	subclassResponsibility
)
public registerNewObjects = (
	subclassResponsibility
)
public registerObject: anObject identifiedWith: id = (
	subclassResponsibility
				
)
reverseLookup: aMap = (
	| newMap |
	newMap:: Map new.
	
	aMap keysAndValuesDo: [ :k :v | newMap at: v put: k].
	^newMap
)
) : (
)
ArrayChange = (
	^ clientServerSync ArrayChange.
)
ArrayDefinition = (
	^ clientServerSync ArrayDefinition.
)
ClassDefinition = (
	^ clientServerSync ClassDefinition.
)
ClientToServerChangeLog = (
	^ clientServerSync ClientToServerChangeLog.
)
NewObjectReference = (
	^ clientServerSync NewObjectReference.
)
ObjectChangeRecord = (
	^ clientServerSync ObjectChangeRecord.
)
ObjectDefinition = (
	^ clientServerSync ObjectDefinition.
)
ObjectDefinitionWithIdentification = (
	^ clientServerSync ObjectDefinitionWithIdentification.
)
ObjectReference = (
	^ clientServerSync ObjectReference.
)
ObjectReferenceByMessageSend = (
	^ clientServerSync ObjectReferenceByMessageSend.
)
RegularObjectChange = (
	^ clientServerSync RegularObjectChange.
)
ServerToClientChangeLog = (
	^ clientServerSync ServerToClientChangeLog.
)
UnidentifiableObject = (
	^ clientServerSync UnidentifiableObject.
)
garbageCollect  = (
	Smalltalk garbageCollect.  
)
) : (
)
