Newspeak3
'Root'
class Documents usingPlatform: p ide: webIDE  = (
(*
This module supports the live editing of documents that include rich text and live widgets.

It implements an editor with two views: one view is a text editor on raw HTML, and the second is the same HTML, rendered. The editor is live - every edit causes immediate change in the rendered HTML.

Importantly, the HTML can specify embedded Hopscotch fragments using Ampleforth (still unsupported).  Indeed, the primary purpose here is to facilitate the creation of live documents which include programmed UI elements such as live literate programs. 

Design discussion:

The question arises, how to specify the mapping from class names used in the HTML to actual fragments. This mapping is required by Ampleforth. The set of UI elements one might want to embed is open-ended, and often created by the document author. Therefore we need to able to compute a fragment instance in the context of the document. This leads to the need to access all standard fragment classes, and to able to load new ones. Better yet, it would be nice to support widget development within the tool.

The above leads to the view that  this tool is an extension of the IDE (or even, part of the IDE). Need to figure out how to provide it in the UI. We will perhaps want a workspace that has access to this editor (or conversely, a presenter on the editor that has access to the IDE namespace) so that we can define the mapping that will be used by Ampleforth. And we'd want access to the IDE namespace, and so we end up with what  amounts to providing the IDE as part of the tool. It then seems natural to make this part of the IDE, so the namespace access, as well as search, help and workspaces are part of the UI already. Then the mapping is a slot of this module and accessible from regular workspaces. We have one mapping for all documents. We could also have per subject mappings, and set them on subject creation, managing them as sub-namespaces in the IDE.
*)
    |	
    private Map = p collections Map.
    private Subject = p hopscotch Subject.
    private Presenter = p hopscotch Presenter.
  private ObjectMirror = p mirrors ObjectMirror.
  private Color = p graphics Color.
    private ObjectSubject = webIDE browsing ObjectSubject.
    private ProgrammingPresenter = webIDE browsing ProgrammingPresenter.
    private Root = webIDE namespacing Root.
    private ide = webIDE.
    private retainedPlatform = p.
  |
  webIDE browsing addObjectViews: {TwoViewEditorPresenter} forKind: 'isKindOfDocument'.
) (
public class TwoViewEditorSubject onModel: m <Document> = Subject onModel: m (
  | public isAmpleforth <Boolean> ::= true. |
) (
public createPresenter ^ <Presenter>  = (
  ^TwoViewEditorPresenter onSubject: self
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTwoViewEditorSubject
)
public isKindOfTwoViewEditorSubject ^ <Boolean> = (
  ^true
)
public document ^ <Document> = (
  ^model
)
public mapping = (
  ^document mapping
)
public setText: s <String> = (
  document contents: s
)
public text ^ <String> = (
  ^document contents
)
) : (
public named: n <String> initialContents: s <String> = (
  ^onModel: (Document named: n contents: s)
)
)
public class TwoViewEditorPresenter onDocumentSubject: s <TwoViewEditorSubject> = Presenter onSubject: s (
  | rendered <HolderComposer> = holder: render. |
) (
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  ^visual
)
render ^ <Fragment> = (
  ^subject isAmpleforth ifTrue: [ampleforth: subject text mapping: subject mapping] ifFalse: [html: subject text]
)
public isKindOfTwoViewEditorPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTwoViewEditorPresenter
)
definition ^ <Fragment> = (
  | cm <CodeMirrorFragment> = codeMirror: subject text. | 
  rendered content: render. 
  cm useEditControls: false.
  cm 
    changeResponse: [:ed <CodeMirrorFragment> :event <Event>  | 
    subject setText: ed textBeingAccepted. 
    rendered content: render
    ]; 
    (*cancelResponse: cancelResponse;*)
    acceptResponse: [:ed <CodeMirrorFragment> :event <Event>  | updateGUI: [ subject setText: ed textBeingAccepted]].
  ^row: { expanded: [cm] collapsed: [nothing]. rendered}
)
) : (
public onSubject: os <ObjectSubject> ^ <Instance> = (
  ^onDocumentSubject: (TwoViewEditorSubject onModel: os objectMirror reflectee)
)
)
public class Document named: n <String> contents: s <String> mapping: m <Map[Symbol, Fragment]> = ProgrammingPresenter onSubject: dummySubject (
(*
A Document provides a context for evaluating Newspeak code, in order to present live Hopscotch fragments within the text. Access to the all the standard fragments is provided by inheriting them from ProgrammingPresenter. This inheritance is done only for that purpose; Document isn't a Presenter! We also want access to the IDE namespace, in support of literate programming. The #doesNotUnderstand: method provides this access.
Lastly, we implement  #evaluateFragment: method that allows for evaluating expressions in the context of the Document, for reasons explained below.

By convention, the Document is made available to AmpleforthFragment via the mapping, under the key 'AmpleforthTargetDocument'. This allows AmpleforthFragment to process amplets, DOM nodes containing arbitrary Newspeak code snippets that produce Hopscotch fragments, by evaluating them as message sends to the Document. We use this convention because we don't want Hopscotch to depend on mirrors (most UI applications do not need mirrors as part of the platform) - neither directly or indirectly via Document. Hence Hopscotch, and in particular, AmpleforthFragment, cannot implement such evaluation by itself and must be given the Document instead. We can't give it the mirror, because the mapping must only consist of fragments.
*)
	|
    public name <String> ::= n.
	public contents <String> ::= s.
	public mapping <Map[Symbol, Fragment]> = m.
    mirror = ObjectMirror reflecting: self.
	|
    mapping at: 'AmpleforthTargetDocument' put: self.
) (
public isKindOfDocument ^ <Boolean> = (
  ^true
)
doesNotUnderstand: message = (
	^Root
		at: message selector
		ifAbsent: [super doesNotUnderstand: message]
)
platform = (
  ^retainedPlatform
)
public evaluate: expr <String> ^ <ThreadMirror> = (
  ^mirror evaluate: expr
)
public evaluateFragment: expr <String> ^ <Fragment> = (
  | t <ThreadMirror | Error> = [evaluate: expr] on: Error do: [:ce | ce]. |
  t isKindOfThreadMirror ifFalse: [
  ^(link: t printString action: [inspectObjectMirror: (ObjectMirror reflecting: t)])
    color: (Color r: 1 g: 0 b: 0)  
  ].
  t isBroken ifTrue: [
        ^(link: t result reflectee printString action:[enterSubject: (ide debugging ThreadSubject onModel: t)])
         color: (Color r: 1 g: 0 b: 0)].
  t result reflectee isKindOfFragment ifFalse: [
        ^(link:expr, ' does not evaluate to a valid Hopscotch fragment but to: ', t result reflectee printString
  action: [(inspectObjectMirror: t result)])
  color: (Color r: 1 g: 0 b: 0)].
  ^t result reflectee
)
  
public isKindOfPresenter ^ <Boolean> = (
  (* we inherit from Presenter for implementation reasons only; just to provide access to all the standard fragment creation methods *)
  ^false
)
public isKindOfProgrammingPresenter ^ <Boolean> = (
  (* we inherit from ProgrammingPresenter for implementation reasons only; just to provide access to all theg standard fragment creation methods *)
  ^false
)
) : (
public named: n <String> contents: s <String>^ <Instance> = (
  ^named: n contents: s mapping: Map new
)
)
public freshDocumentNamed: n <Symbol> ^ <Document> = (
  ^Document named: n contents: 'Edit HTML here'
)
dummySubject ^ <Subject> = (
  ^Subject onModel: nil  
)
) : (
)
