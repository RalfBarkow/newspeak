Newspeak3
'Root'
class Documents usingPlatform: p ide: webIDE  = (
(*
This module supports the live editing of documents that include rich text and live widgets.

It implements an editor with two views: one view is a text editor on raw HTML, and the second is the same HTML, rendered. The editor is live - every edit causes immediate change in the rendered HTML.

Importantly, the HTML can specify embedded Hopscotch fragments using Ampleforth (still unsupported).  Indeed, the primary purpose here is to facilitate the creation of live documents which include programmed UI elements such as live literate programs. 

Design discussion:

The question arises, how to specify the mapping from class names used in the HTML to actual fragments. This mapping is required by Ampleforth. The set of UI elements one might want to embed is open-ended, and often created by the document author. Therefore we need to able to compute a fragment instance in the context of the document. This leads to the need to access all standard fragment classes, and to able to load new ones. Better yet, it would be nice to support widget development within the tool.

The above leads to the view that  this tool is an extension of the IDE (or even, part of the IDE). Need to figure out how to provide it in the UI. We will perhaps want a workspace that has access to this editor (or conversely, a presenter on the editor that has access to the IDE namespace) so that we can define the mapping that will be used by Ampleforth. And we'd want access to the IDE namespace, and so we end up with what  amounts to providing the IDE as part of the tool. It then seems natural to make this part of the IDE, so the namespace access, as well as search, help and workspaces are part of the UI already. Then the mapping is a slot of this module and accessible from regular workspaces. We have one mapping for all documents. We could also have per subject mappings, and set them on subject creation, managing them as sub-namespaces in the IDE.
*)
    |	
    private Map = p collections Map.
    private Subject = p hopscotch Subject.
    private Presenter = p hopscotch Presenter.
    private DOMParser = p hopscotch DOMParser.
    private ObjectMirror = p mirrors ObjectMirror.
    private Color = p graphics Color.
    private ProgrammingPresenter = webIDE browsing ProgrammingPresenter.
    private NamespaceSubject = webIDE browsing NamespaceSubject.
    private Root = webIDE namespacing Root.
    private ide = webIDE.
    private retainedPlatform = p.
  |
  webIDE browsing addObjectViews: {DocumentPresenter} forKind: 'isKindOfDocument'.
) (
public class TwoViewEditorSubject onModel: m <Document> = Subject onModel: m (
  | public isAmpleforth <Boolean> ::= true. |
) (
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTwoViewEditorSubject
)
public isKindOfTwoViewEditorSubject ^ <Boolean> = (
  ^true
)
public document ^ <Document> = (
  ^model
)
public setText: s <String> = (
  document contents: s
)
public text ^ <String> = (
  ^document contents
)
public name ^ <String> = (
  ^document name
)
public createPresenter ^ <Presenter>  = (
  ^TwoViewEditorPresenter onDocumentSubject: self
)
) : (
public named: n <String> initialContents: s <String> = (
  ^onModel: (Document named: n contents: s)
)
)
public class TwoViewEditorPresenter onDocumentSubject: s <TwoViewEditorSubject> = Presenter onSubject: s (
  |
  mapping <Map[Symbol, Fragment]> = Map new at: 'AmpleforthTargetDocument' put: subject document; yourself.    
  rendered <HolderComposer> = holder: render. 
  |
) (
public isKindOfTwoViewEditorPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTwoViewEditorPresenter
)
render ^ <Fragment> = (
  ^subject isAmpleforth ifTrue: [ampleforth: subject text mapping: mapping] ifFalse: [html: subject text]
)
definition ^ <Fragment> = (
  | cm <CodeMirrorFragment> = codeMirror: subject text. | 
  rendered content: render. 
  cm useEditControls: false.
  cm 
    changeResponse: [:ed <CodeMirrorFragment> :event <Event>  | 
    subject setText: ed textBeingAccepted. 
    rendered content: render
    ]; 
    acceptResponse: [:ed <CodeMirrorFragment> :event <Event>  | updateGUI: [subject setText: ed textBeingAccepted]].
    ^row: { collapsed: [nothing] expanded: [cm]. rendered}
)
) : (
public onSubject: os <ObjectSubject> ^ <Instance> = (
  ^onDocumentSubject: (TwoViewEditorSubject onModel: os objectMirror reflectee)
)
)
public class Document named: n <String> contents: s <String> = ProgrammingPresenter onSubject: dummySubject (
(*
A Document provides a context for evaluating Newspeak code, in order to present live Hopscotch fragments within the text. Access to the all the standard fragments is provided by inheriting them from ProgrammingPresenter. This inheritance is done only for that purpose; Document isn't a Presenter! We also want access to the IDE namespace, in support of literate programming. The #doesNotUnderstand: method provides this access.
Lastly, we implement  #evaluateFragment: method that allows for evaluating expressions in the context of the Document, for reasons explained below.

By convention, the Document is made available to AmpleforthFragment via the mapping, under the key 'AmpleforthTargetDocument'. This allows AmpleforthFragment to process amplets, DOM nodes containing arbitrary Newspeak code snippets that produce Hopscotch fragments, by evaluating them as message sends to the Document. We use this convention because we don't want Hopscotch to depend on mirrors (most UI applications do not need mirrors as part of the platform) - neither directly or indirectly via Document. Hence Hopscotch, and in particular, AmpleforthFragment, cannot implement such evaluation by itself and must be given the Document instead. We can't give it the mirror, because the mapping must only consist of fragments.
*)
	|
    public name <String> ::= n.
	public contents <String> ::= s.
    mirror = ObjectMirror reflecting: self.
	|
) (
public isKindOfDocument ^ <Boolean> = (
  ^true
)
doesNotUnderstand: message = (
	^Root
		at: message selector
		ifAbsent: [super doesNotUnderstand: message]
)
platform = (
  ^retainedPlatform
)
public evaluate: expr <String> ^ <ThreadMirror> = (
  ^mirror evaluate: expr
)
public isKindOfPresenter ^ <Boolean> = (
  (* we inherit from Presenter for implementation reasons only; just to provide access to all the standard fragment creation methods *)
  ^false
)
public isKindOfProgrammingPresenter ^ <Boolean> = (
  (* we inherit from ProgrammingPresenter for implementation reasons only; just to provide access to all theg standard fragment creation methods *)
  ^false
)
public evaluateFragment: expr <String> ^ <Fragment> = (
  | t <ThreadMirror | Error> = [evaluate: expr] on: Error do: [:ce | ce]. |
  t isKindOfThreadMirror ifFalse: [
  ^(link: t printString action: [inspectObjectMirror: (ObjectMirror reflecting: t)])
    color: (Color r: 1 g: 0 b: 0)  
  ].
  t isBroken ifTrue: [
        ^(link: t result reflectee printString action: [enterSubject: (ide debugging ThreadSubject onModel: t)])
         color: (Color r: 1 g: 0 b: 0)].
  t result reflectee isKindOfFragment ifFalse: [
        ^(link: expr, ' does not evaluate to a valid Hopscotch fragment but to: ', t result reflectee printString
  action: [(inspectObjectMirror: t result)])
  color: (Color r: 1 g: 0 b: 0)].
  ^t result reflectee
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfDocument
)
definition = (
  ^hyperrealError
)
hyperrealError = (
  ^html: '<p style="color:red;"><b>Doubleplus Ungoodness Detected.</b></p>
<p style="color:red;">Document  <i>', name, '</i> is attempting to embed
itself within itself. This would require infinite space<a href = ''#footnote1''><sup>1</sup></a>. The most
likely cause is an <i>ampleforth</i> element referring to a method returning
<b>self</b> (or else, to #AmpleforthTargetDocument). Perhaps you forgot a return?</p>
<p style="color:red;">If you really meant to do this, you need to mediate via a link or
button. Otherwise, the Ministry of Truth recommends  <i>On Exactitude in Science</i> by Borges.</p>
<p id="footnote1" style="color:red;">[1] If we could provide you with infinite space, you think we''d be
bothered writing code for mortals like you to use?</p>'
)
) : (
)
class DocumentPresenter onDocumentSubject: s = ProgrammingPresenter onSubject: s (
) (
public isKindOfDocumentPresenter ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean>  = (
  ^other isKindOfDocumentPresenter
)
respondToDelete = (
	updateGUI: [
      Root removeKey: subject name. 
      enterSubject: NamespaceSubject new
      ]
)
definition ^ <Fragment> = (
  ^column: {
       collapsed: [nothing] expanded: [row: {
         label: subject name.
         smallBlank.
         itemReferencesButtonWithAction: [browseSelector: subject name].
         smallBlank.
         saveButtonWithAction: [subject save].
         smallBlank.
         refreshButton.			
         smallBlank.
         helpButton.
         smallBlank.
         dropDownMenu: [docMenu].
        }].
       (TwoViewEditorSubject onModel:  subject document) presenter.
  }
)
docMenu ^ <Menu> = (
  (* Need inspect presenter, delete *)
  ^menuWithLabelsAndActions: {
        {'Inspect Document'. [respondToInspectDocument]}.
        {'Inspect Presenter'. [respondToInspectPresenter]}.
        {'Delete'. [respondToDelete]}.
	}
)
respondToInspectDocument = (
      enterSubject: ide browsing ObjectSubject onModel: (ObjectMirror reflecting: subject document)
)
) : (
public onSubject: os <ObjectSubject> ^ <Instance> = (
  ^onDocumentSubject: (DocumentSubject onModel: os objectMirror reflectee)
)
)
public class DocumentSubject onModel: m <Document> = Subject onModel: m (
) (
public isKindOfDocumentSubject ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfDocumentSubject
)
public name ^ <String> = (
  ^document name
)
public document ^ <Document> = (
  ^model
)
public save = (
	ide webFiles downloadFileName: name, '.html' fromString: document contents. 
)
public createPresenter ^ <DocumentPresenter> = (
  ^DocumentPresenter onDocumentSubject: self
)
) : (
)
class ADocument contents: c <String> = Document named: #ADocument contents: c 
() (
notAFragment = (^33)
testButton1 = (^button: #TestButton1 action: ['testing' out])
testButton2 = (^button: #TestButton2 action: ['testing' out])
testButton3 = (^button: #TestButton3 action: ['testing' out])
testButton4 = (^button: #TestButton4 action: ['testing' out])
toggle = (^expanded: (testButton4) collapsed: (label: 'open'))
) : (
)
class WhatIsLiveProgramming contents: c <String> = Document named: #WhatIsLiveProgramming contents: c 
(
| 
ui = CounterUI usingPlatform: platform.
counterSubject = ui CounterSubject onModel: ui Counter new.
|
) (
counter ^ <CounterPresenter> = (^counterSubject presenter)
counterDefinition ^ <MethodPresenter> = (
^ (ide browsing MethodSubject onModel:
(((platform mirrors ClassMirror reflecting: CounterUI) nestedClasses 
findMirrorNamed: #CounterPresenter ) instanceSide methods 
  findMirrorNamed: #definition)) presenter
)
) : (
)
dummySubject ^ <Subject> = (
  ^Subject onModel: nil  
)
public freshDocumentNamed: n <Symbol> ^ <Document> = (
  ^freshDocumentNamed: n contents: 'Edit HTML here'
)
createDocumentSubclassNamed: n <Symbol> body: b <String> ^ <Class> (* :exemplar: createDocumentSubclassNamed: #ADoc body: '()()' *)= ( 
  | 
  src <String> = 'class ', n,  ' contents: c <String> = Document named: #', n , ' contents: c ',  b. 
  mb <MixinBuilder> = (ObjectMirror reflecting: self) getClass mixin asBuilder.
  |
  mb nestedClasses addFromSource: src.
  mb declaration install.
  ^((ObjectMirror reflecting: self) evaluate: n) result reflectee
)
public freshDocumentNamed: n <Symbol> contents: c <String> ^ <Document> = (

  | 
  DOM <Alien[Element]> = DOMParser new parseFromString: c mimeType: 'text/html'.
  candidates <Alien[Array[Element]]> = DOM getElementsByClassName: #ampleforthDocumentClass.
  ampleforthDocumentClass <Alien[Element] | Nil> = ((candidates at: 'length') = 0) ifFalse: [candidates at: 0].
 classBody <String>
 className <String> = ampleforthDocumentClass getAttribute: #name.
 |
 classBody:: (ampleforthDocumentClass isNil not and: [ampleforthDocumentClass hasAttribute: #classBody])   
    ifTrue: [ampleforthDocumentClass getAttribute: #classBody]
    ifFalse: ['()()'].
  ^(createDocumentSubclassNamed: n body: classBody) contents: c
)
) : (
)
