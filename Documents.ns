Newspeak3
'Root'
class Documents usingPlatform: p ide: webIDE  = (
(*
This module supports the live editing of documents that include rich text and live widgets.

It implements an editor with two views: one view is a text editor on raw HTML, and the second is the same HTML, rendered. The editor is live - every edit causes immediate change in the rendered HTML.

Importantly, the HTML can specify embedded Hopscotch fragments using Ampleforth (still unsupported).  Indeed, the primary purpose here is to facilitate the creation of live documents which include programmed UI elements such as live literate programs. 

Design discussion:

The question arises, how to specify the mapping from class names used in the HTML to actual fragments. This mapping is required by Ampleforth. The set of UI elements one might want to embed is open-ended, and often created by the document author. Therefore we need to able to compute a fragment instance in the context of the document. This leads to the need to access all standard fragment classes, and to able to load new ones. Better yet, it would be nice to support widget development within the tool.

The above leads to the view that  this tool is an extension of the IDE (or even, part of the IDE). Need to figure out how to provide it in the UI. We will perhaps want a workspace that has access to this editor (or conversely, a presenter on the editor that has access to the IDE namespace) so that we can define the mapping that will be used by Ampleforth. And we'd want access to the IDE namespace, and so we end up with what  amounts to providing the IDE as part of the tool. It then seems natural to make this part of the IDE, so the namespace access, as well as search, help and workspaces are part of the UI already. Then the mapping is a slot of this module and accessible from regular workspaces. We have one mapping for all documents. We could also have per subject mappings, and set them on subject creation, managing them as sub-namespaces in the IDE.
*)
    |	
    private Map = p collections Map.
    private Subject = p hopscotch Subject.
    private Presenter = p hopscotch Presenter.
    private Workspace = webIDE theWorkspaceManager Workspace.
  |
  webIDE browsing addObjectViews: {TwoViewEditorPresenter} forKind: 'isKindOfDocument'.
) (
public class TwoViewEditorSubject onModel: m <Document> = Subject onModel: m (
  | public isAmpleforth <Boolean> ::= false. |
) (
public createPresenter ^ <Presenter>  = (
  ^TwoViewEditorPresenter onSubject: self
)
public isKindOfTwoViewSubject ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTwoViewSubject
)
public setText: s <String> = (
  model contents: s
)
public text ^ <String> = (
  ^model contents
)
) : (
public named: n <String> initialContents: s <String> = (
  ^onModel: (Document named: n contents: s)
)
)
public class TwoViewEditorPresenter onDocumentSubject: s <TwoViewEditorSubject> = Presenter onSubject: s (
  | rendered <HolderComposer> = holder: render. |
) (
public isKindOfTwoViewPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTwoViewPresenter
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  ^visual
)
render ^ <Fragment> = (
  ^subject isAmpleforth ifTrue: [ampleforth: subject text mapping: subject mapping] ifFalse: [html: subject text]
)
definition ^ <Fragment> = (
  | cm <CodeMirrorFragment> = codeMirror: subject text. | 
  rendered content: render. 
  cm 
    changeResponse: [:ed <CodeMirrorFragment> :event <Event>  | 
    subject setText: ed textBeingAccepted. 
    rendered content: render
    ]; 
    (*cancelResponse: cancelResponse;*)
    acceptResponse: [:ed <CodeMirrorFragment> :event <Event>  | updateGUI: [ subject setText: ed textBeingAccepted]].
  ^row: { expanded: [cm] collapsed: [nothing]. rendered}
)
) : (
public onSubject: os <ObjectSubject> ^ <Instance> = (
  ^onDocumentSubject: (TwoViewEditorSubject onModel: os objectMirror reflectee)
)
)
public class Document named: n <String> contents: s <String> mapping: m <Map[Symbol, Fragment]> = Workspace (
	|
        public name <String> ::= n.
	public contents <String> ::= s.
	public mapping <Map[Symbol, Fragment]> = m.
	|
) (
public isKindOfDocument ^ <Boolean> = (
  ^true
)
) : (
public named: n <String> contents: s <String>^ <Instance> = (
  ^named: n contents: s mapping: Map new
)
)
public freshDocumentNamed: n <Symbol> ^ <Document> = (
  ^Document named: n contents: 'Edit HTML here'
)
) : (
)
