Newspeak3
'Root'
class Documents usingPlatform: p ide: webIDE  = (
(*
This module supports the live editing of documents that include rich text and live widgets.

It implements an editor with two views: one view is a text editor on raw HTML, and the second is the same HTML, rendered. The editor is live - every edit causes immediate change in the rendered HTML.

Importantly, the HTML can specify embedded Hopscotch fragments using Ampleforth (still unsupported).  Indeed, the primary purpose here is to facilitate the creation of live documents which include programmed UI elements such as live literate programs. 

Design discussion:

The question arises, how to specify the mapping from class names used in the HTML to actual fragments. This mapping is required by Ampleforth. The set of UI elements one might want to embed is open-ended, and often created by the document author. Therefore we need to able to compute a fragment instance in the context of the document. This leads to the need to access all standard fragment classes, and to able to load new ones. Better yet, it would be nice to support widget development within the tool.

The above leads to the view that  this tool is an extension of the IDE (or even, part of the IDE). Need to figure out how to provide it in the UI. We will perhaps want a workspace that has access to this editor (or conversely, a presenter on the editor that has access to the IDE namespace) so that we can define the mapping that will be used by Ampleforth. And we'd want access to the IDE namespace, and so we end up with what  amounts to providing the IDE as part of the tool. It then seems natural to make this part of the IDE, so the namespace access, as well as search, help and workspaces are part of the UI already. Then the mapping is a slot of this module and accessible from regular workspaces. We have one mapping for all documents. We could also have per subject mappings, and set them on subject creation, managing them as sub-namespaces in the IDE.
*)
    |	
    private Map = p collections Map.
    private Subject = p hopscotch Subject.
    private Presenter = p hopscotch Presenter.
    private DOMParser = p hopscotch DOMParser.
    private ClassMirror = p mirrors ClassMirror.    
    private ObjectMirror = p mirrors ObjectMirror.
    private Color = p graphics Color.
    private ProgrammingPresenter = webIDE browsing ProgrammingPresenter.
    private NamespaceSubject = webIDE browsing NamespaceSubject.
    private Root = webIDE namespacing Root.
    private ide = webIDE.
    private retainedPlatform = p.
  |
  webIDE browsing addObjectViews: {DocumentPresenter} forKind: 'isKindOfDocument'.
) (
public class TwoViewEditorSubject onModel: m <Document> = Subject onModel: m (
  | public isAmpleforth <Boolean> ::= true. |
) (
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTwoViewEditorSubject
)
public isKindOfTwoViewEditorSubject ^ <Boolean> = (
  ^true
)
public document ^ <Document> = (
  ^model
)
public setText: s <String> = (
  document contents: s
)
public text ^ <String> = (
  ^document contents
)
public name ^ <String> = (
  ^document name
)
public createPresenter ^ <Presenter>  = (
  ^TwoViewEditorPresenter onDocumentSubject: self
)
) : (
public named: n <String> initialContents: s <String> = (
  ^onModel: (Document named: n contents: s)
)
)
public class TwoViewEditorPresenter onDocumentSubject: s <TwoViewEditorSubject> = Presenter onSubject: s (
  |
  mapping <Map[Symbol, Fragment]> = Map new at: 'AmpleforthTargetDocument' put: subject document; yourself.    
  rendered <HolderComposer> = holder: render. 
   (* Is the user is editing the live view? *)
  updatingFromLive <Boolean> ::= false. 
  cm <CodeMirrorFragment>  
  |
) (
public isKindOfTwoViewEditorPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTwoViewEditorPresenter
)
render ^ <Fragment> = (
  | result <AmpleforthFragment> = subject isAmpleforth ifTrue: [ampleforth: subject text mapping: mapping] ifFalse: [html: subject text]. |
  (*result onClick: [alert: 'I got clicked'].*)
  ^result
)
definition ^ <Fragment> = (
  cm:: codeMirror: subject text.
  updateFromRawView: cm.
  cm useEditControls: false.
  cm 
    changeResponse: [:ed <CodeMirrorFragment> :event <Event>  | 
    subject setText: ed textBeingAccepted. 
    updatingFromLive 
      ifTrue: [(* Reset updatingFromLive, in case the user edits the raw view next;
                        The live view' handler(s) will programmatically update the rest *)
        updatingFromLive: false
        ]  ifFalse: [(* The change is a result of editing the raw view by the user; update accordingly *)
        updateFromRawView: cm
      ].
    ]; 
    acceptResponse: [:ed <CodeMirrorFragment> :event <Event>  | updateGUI: [subject setText: ed textBeingAccepted]].
    ^row: { collapsed: [nothing] expanded: [cm]. rendered}
)
scrubbedLiveViewSource ^ <String> = (
(* The live view's innerHTML contains the HTML sources for the live widgets added into it.
     Before we use this to set the raw view source, these must be eliminated. They not only
     pollute the model, but can lead to duplicate widgets as well.
     *)
  |
  treeCopy = rendered visual cloneNode: true.
  amplets <Alien[HTMLCollection[Node]]> = treeCopy getElementsByClassName: #ampleforth. |
  0 to: (amplets at: #length) - 1 do: [:i <Integer> | | amplet <Alien[Node]> = amplets item: i. |
  amplet removeChild: (amplet at: #firstChild)
  ].
  ^treeCopy at: #innerHTML
)
addUpdateHandlerBasedOn: cm  <CodeMirrorFragment> = (
  (* Add an update handler to the new live view. *)
  (rendered content visual at: #firstChild) at: #updateRawHTML put: [
    (* Note that the live view was edited *)
    updatingFromLive: true. 
    (* Update the raw view based on the live view *)
    cm text: scrubbedLiveViewSource. 
    nil].
)
updateFromRawView: cm <CodeMirrorFragment> = (
  (* Recompute the live view using #render and update the holder *)
  rendered content: render.
  (* Add an update handler to the new live view. *)
  addUpdateHandlerBasedOn: cm
)
updateVisualsFromSameKind: oldPresenter <Self> ^ <Alien[Element]> = (
  | result <Alien[Element]> = super updateVisualsFromSameKind: oldPresenter. |
  addUpdateHandlerBasedOn: cm.
  ^result
)
) : (
public onSubject: os <ObjectSubject> ^ <Instance> = (
  ^onDocumentSubject: (TwoViewEditorSubject onModel: os objectMirror reflectee)
)
)
public class Document named: n <String> contents: s <String> = ProgrammingPresenter onSubject: dummySubject (
(*
A Document provides a context for evaluating Newspeak code, in order to present live Hopscotch fragments within the text. Access to the all the standard fragments is provided by inheriting them from ProgrammingPresenter. This inheritance is done only for that purpose; Document isn't a Presenter! We also want access to the IDE namespace, in support of literate programming. The #doesNotUnderstand: method provides this access.
Lastly, we implement  #evaluateFragment: method that allows for evaluating expressions in the context of the Document, for reasons explained below.

By convention, the Document is made available to AmpleforthFragment via the mapping, under the key 'AmpleforthTargetDocument'. This allows AmpleforthFragment to process amplets, DOM nodes containing arbitrary Newspeak code snippets that produce Hopscotch fragments, by evaluating them as message sends to the Document. We use this convention because we don't want Hopscotch to depend on mirrors (most UI applications do not need mirrors as part of the platform) - neither directly or indirectly via Document. Hence Hopscotch, and in particular, AmpleforthFragment, cannot implement such evaluation by itself and must be given the Document instead. We can't give it the mirror, because the mapping must only consist of fragments.
*)
	|
    public name <String> ::= n.
	public contents <String> ::= s.
    mirror = ObjectMirror reflecting: self.
	|
) (
public isKindOfDocument ^ <Boolean> = (
  ^true
)
doesNotUnderstand: message = (
	^Root
		at: message selector
		ifAbsent: [super doesNotUnderstand: message]
)
platform = (
  ^retainedPlatform
)
public evaluate: expr <String> ^ <ThreadMirror> = (
  ^mirror evaluate: expr
)
public isKindOfPresenter ^ <Boolean> = (
  (* we inherit from Presenter for implementation reasons only; just to provide access to all the standard fragment creation methods *)
  ^false
)
public isKindOfProgrammingPresenter ^ <Boolean> = (
  (* we inherit from ProgrammingPresenter for implementation reasons only; just to provide access to all theg standard fragment creation methods *)
  ^false
)
public evaluateFragment: expr <String> ^ <Fragment> = (
  | t <ThreadMirror | Error> = [evaluate: expr] on: Error do: [:ce | ce]. |
  t isKindOfThreadMirror ifFalse: [
  ^(link: t printString action: [inspectObjectMirror: (ObjectMirror reflecting: t)])
    color: (Color r: 1 g: 0 b: 0)  
  ].
  t isBroken ifTrue: [
        ^(link: t result reflectee printString action: [enterSubject: (ide debugging ThreadSubject onModel: t)])
         color: (Color r: 1 g: 0 b: 0)].
  t result reflectee isKindOfFragment ifFalse: [
        ^(link: expr, ' does not evaluate to a valid Hopscotch fragment but to: ', t result reflectee printString
  action: [(inspectObjectMirror: t result)])
  color: (Color r: 1 g: 0 b: 0)].
  ^t result reflectee
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfDocument
)
definition = (
  ^hyperrealError
)
public classSource ^ <String> = (
  | src = mirror getClass mixin declaration source. |
  ^src copyFrom: (src indexOf: '(') to: src size.
)
public hash ^ <Integer> = (
  ^ name hash bitXor: contents hash
)
public = other ^ <Boolean> = (
(* We cannot rely on the inherited = from Presenter, as this is really a fake presenter and not displayed directly *)
  ^name = other name and: [contents = other contents]
)
hyperrealError = (
  ^html: '<p style="color:red;"><b>Doubleplus Ungoodness Detected.</b></p>
<p style="color:red;">Document  <i>', name, '</i> is attempting to embed
itself within itself. This would require infinite space<a href = ''#footnote1''><sup>1</sup></a>. The most
likely cause is an <i>ampleforth</i> element referring to a method returning
<b>self</b> (or else, to #AmpleforthTargetDocument). Perhaps you forgot a return?</p>
<p style="color:red;">If you really meant to do this, you need to mediate via a link or
button. Otherwise, the Ministry of Truth recommends <a href = "https://kwarc.info/teaching/TDM/Borges.pdf"><i>On Exactitude in Science</i></a> by Borges.</p>
<p id="footnote1" style="color:red;">[1] If we could provide you with infinite space, you think we''d be
bothered writing code for mortals like you to use?</p>'
)
) : (
)
class DocumentPresenter onDocumentSubject: s = ProgrammingPresenter onSubject: s (
) (
public isKindOfDocumentPresenter ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean>  = (
  ^other isKindOfDocumentPresenter
)
respondToDelete = (
	updateGUI: [
      Root removeKey: subject name. 
      enterSubject: NamespaceSubject new
      ]
)
docMenu ^ <Menu> = (
  (* Need inspect presenter, delete *)
  ^menuWithLabelsAndActions: {
        {'Show Code'. [respondToInspectDocument]}.
        {'Inspect Presenter'. [respondToInspectPresenter]}.
        {'Delete'. [respondToDelete]}.
	}
)
respondToInspectDocument = (
      enterSubject: (ide browsing ObjectSubject onModel: (ObjectMirror reflecting: subject document))
)
definition ^ <Fragment> = (
  ^column: {
       helpSection.
       collapsed: [nothing] expanded: [row: {
         label: subject name.
         smallBlank.
         itemReferencesButtonWithAction: [browseSelector: subject name].
         smallBlank.
         saveButtonWithAction: [subject save].
         smallBlank.
         refreshButton.			
         smallBlank.
         helpButton.
         smallBlank.
         dropDownMenu: [docMenu].
        }].
       (TwoViewEditorSubject onModel:  subject document) presenter.
  }
)
helpText ^ <AmpleforthFragment> = (
  | mapping = Map new. |
  ^ampleforth: 'This is a DocumentPresenter. ' mapping: mapping
)
) : (
public onSubject: os <ObjectSubject> ^ <Instance> = (
  ^onDocumentSubject: (DocumentSubject onModel: os objectMirror reflectee)
)
)
public class DocumentSubject onModel: m <Document> = Subject onModel: m (
) (
public isKindOfDocumentSubject ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfDocumentSubject
)
public name ^ <String> = (
  ^document name
)
public document ^ <Document> = (
  ^model
)
public createPresenter ^ <DocumentPresenter> = (
  ^DocumentPresenter onDocumentSubject: self
)
public save = (
	ide webFiles downloadFileName: name, '.html' fromString: completeHTML. 
)
psoupHTML ^ <String> = (
  ^'   <script type="text/javascript">
      function scheduleTurn(timeout) {
        if (timeout >= 0) {
          setTimeout(function() {
            var timeout = Module._handle_message();
            scheduleTurn(timeout);
          }, timeout);
        }
      }

      var Module = {
        noInitialRun: true,
        noExitRuntime: true,
        onRuntimeInitialized: function() {
          var url = new URLSearchParams(window.location.search);
          var request = new XMLHttpRequest();
          request.open("GET", url.get("snapshot"), true);
          request.responseType = "arraybuffer";
          request.onload = function (event) {
            var jsBuffer = new Uint8Array(request.response);
            var cBuffer = _malloc(jsBuffer.length);
            writeArrayToMemory(jsBuffer, cBuffer);
            Module._load_snapshot(cBuffer, jsBuffer.length);
            _free(cBuffer);
            scheduleTurn(0);
          };
          request.send();
        },
        print: function(text) {
          if (arguments.length > 1) {
            text = Array.prototype.slice.call(arguments).join(" ");
          }
          console.log(text);
        },
        printErr: function(text) {
          if (arguments.length > 1) {
            text = Array.prototype.slice.call(arguments).join(" ");
          }
          console.error(text);
        },
        setStatus: function(text) {
          console.log(text);
        },
      };
    </script>
<script async type="text/javascript" src="primordialsoup.js"></script>
    <script src="CodeMirror/lib/codemirror.js"></script>
    <link rel="stylesheet" href="CodeMirror/lib/codemirror.css"></link>
    <script src="CodeMirror/addon/display/autorefresh.js"></script>'
)
completeHTML ^ <String>  = (
  ^'<div class = "ampleforthDocumentClass" name = "', 
  document name, 
  '" classBody = "',
  document classSource,
  '" </div><div class = "ampleforthDocumentBody">', 
  document contents, 
  '</div>', 
  psoupHTML
)
) : (
)
class DummySubject = Subject onModel: nil (
) (
public isKindOfDummySubject ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfDummySubject
)
) : (
)
dummySubject ^ <Subject> = (
  ^DummySubject new  
)
documentHolderMixinBuilder ^ <MixinBuilder> = (
  ^(ObjectMirror reflecting: ide documentHolder) getClass mixin asBuilder
)
createDocumentSubclassNamed: n <Symbol> body: b <String> ^ <Class> (* :exemplar: createDocumentSubclassNamed: #ADoc body: '()()' *)= ( 
  | 
  src <String> = 'public class ', n,  ' contents: c <String> = Document named: #', n , ' contents: c ',  b. 
  mb <MixinBuilder> = documentHolderMixinBuilder.
  |
  mb nestedClasses addFromSource: src.
  mb declaration install.
  ^((ObjectMirror reflecting: ide documentHolder ) evaluate: n) result reflectee
)
public classOfHTMLDocument: dom <Alien[Node]>  ^ <Class> = (

  | 
  candidates <Alien[Array[Element]]> = dom getElementsByClassName: #ampleforthDocumentClass.
  ampleforthDocumentClass <Alien[Element] | Nil> = ((candidates at: 'length') = 0) ifFalse: [candidates at: 0].
  classBody <String>
  className <String> = ampleforthDocumentClass getAttribute: #name.
  |
  classBody:: (ampleforthDocumentClass isNil not and: [ampleforthDocumentClass hasAttribute: #classBody])   
     ifTrue: [ampleforthDocumentClass getAttribute: #classBody]
     ifFalse: ['()()'].
  ^createDocumentSubclassNamed: className body: classBody
)
public freshDocumentFromDOM: dom <Alien[Node]> ^ <Document> = (
  ^(classOfHTMLDocument: dom) contents: (textOfHTMLDocument: dom)
)
public freshDocumentWithContents: c <String> ^ <Document> = (

  | DOM <Alien[Element]> = DOMParser new parseFromString: c mimeType: 'text/html'. |
  ^freshDocumentFromDOM: DOM
)
public freshDocumentNamed: n <Symbol> ^ <Document> = (
  ^freshDocumentWithContents: '<div class = "ampleforthDocumentClass" name = "', n, '" classBody = "
()()"></div><div class = "ampleforthDocumentBody">', defaultAmpleforthDocumentBodyInnerHTML, '</div>'
)
public textOfHTMLDocument: dom  <Alien[Node]>  ^ <String> = (
  | 
  docCandidates = dom getElementsByClassName: 'ampleforthDocumentBody'. 
  ampleforthDocument <Alien[Element] | Nil> = 
    ((docCandidates at: 'length') = 0) ifFalse: [docCandidates at: 0].
  |
  ^ampleforthDocument ~= nil ifTrue: [ampleforthDocument at: #innerHTML]  ifFalse: [defaultAmpleforthDocumentBodyInnerHTML].
)
defaultAmpleforthDocumentBodyInnerHTML ^ <String> = (
  ^'<div class = "self_ampleforth" contenteditable = "true" style="border: 2px solid blue; resize: horizontal; overflow: auto" onkeyup="updateRawHTML()"> <h2>This is a blank document.</h2></div>'
)
) : (
)
