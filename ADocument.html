<div class = "ampleforthDocumentClass" name = "ADocument" classBody = "
()(
notAFragment = (^33)
testButton1 = (^button: #TestButton1 action: ['testing' out])
testButton2 = (^button: #TestButton2 action: ['testing' out])
testButton3 = (^button: #TestButton3 action: ['testing' out])
testButton4 = (^button: #TestButton4 action: ['testing' out])
toggle = (^expanded: (testButton4) collapsed: (label: 'open'))
  )"></div>
<div class = "ampleforthDocumentBody">
<h1> A Sample Document</h1> This is a <div class = "ampleforth" name =
  "testButton1"></div>
  embedded in a document!  
  And here is another one: <span class = "ampleforth" name = "testButton2"></span> and another
<div class = "ampleforth" name = "testButton3"></div>
  <h3> Maintaining State</h3>
  Here is a toggle that maintains its state while we edit:
  <div class = "ampleforth" name = "toggle"></div>
  Let us add another widget <span class = "ampleforth" name = "testButton4"></span>
<h3>Dealing with Errors</h3>
What if the expression given in the document does not evaluate to a
  Fragment? 
  <br>
  If it evaluates without error, we place an
  error message that links to an inspector on the result in the 
  document.
  <br>
<div class = "ampleforth" name = "notAFragment"></div>
<br>
Consider a bad selector in the <i>name</i> attribute of an <i>ampleforth</i> node.
<br>
<div class = "ampleforth" name = "foo"></div>
<br>
If the expression does not compile at all, what do we do? 
<br>No longer an
issue in the new design. 
<br>
Likewise if the <i>initializer</i> attribute is missing.
<br>
Another interesting situation is recursion, as attempted below, which yields an informative error message: 
<br>
<div class = "ampleforth" name = "AmpleforthTargetDocument"><div>
  <br>
  </div>

