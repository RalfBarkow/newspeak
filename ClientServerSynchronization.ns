Newspeak3
'OrthogonalSynchronization'
class ClientServerSynchronization usingPlatform: platform  = (
|		
	Map = platform collections Map.
	ObjectMirror = platform mirrors ObjectMirror.
	ClassMirror = platform mirrors ClassMirror.
	
|
) (
public class ArrayChange withChanges: valuesByIndex  = (
|
	public changes = valuesByIndex.
|) (
public appliedWithChange: aChange = (
	| newChanges |
	newChanges::  newMapFrom: changes. 
	
	aChange changes keysAndValuesDo: [ :k :v  |

		newChanges at: k put: v.	
	].

	^ class withChanges: newChanges.
	
)
public applyIn: aContext usingMirror: objectMirror = (
		
	changes keysAndValuesDo: [ :index	 :reference |
		| referencedObject  |
		referencedObject:: reference referencedObjectFrom: aContext topLevel: nil.
		objectMirror reflectee at:  index put: referencedObject.
	].
)
public asGlobalReferenceUsing: objectStore = (

	|  changesWithGlobalReference |
	
	changesWithGlobalReference:: Map new.
	changes  keysAndValuesDo: [ :key :value |   changesWithGlobalReference at: key put: (value asGlobalReferenceUsing: objectStore)   ].	
	
	^ class withChanges: changesWithGlobalReference.
)
public asObjectChangeRecordForId: anId = (
	^ ObjectChangeRecord 
		for: (ObjectReference toObjectIdentifiedWith:  anId)
		withChange: self.

)
public isKindOfObjectChange = (
	^ true
)
) : (
)
public class ArrayDefinition  withContents: contents  = ObjectDefinitionBase (
|
	contents  = contents.
|
) (
public appliedWithChange: aChange = (
	| newContents |
	newContents::  Array withAll: contents. 
	
	aChange changes keysAndValuesDo: [ :k :v  |

		newContents at: k put: v.	
	].

	^ class withContents: newContents.
	
)
public asGlobalReferenceUsing: objectStore = (
	| globalContents|

	globalContents:: contents collect: [  :value |   value asGlobalReferenceUsing: objectStore   ].	
	^ class withContents: globalContents.
)
public createEmptyInstanceUsingContext: aContext topLevel: aTopLevel = (
	^ Array new: contents size.
)
public fill: anObjectMirror resolvingReferencesWith: anObjectStore topLevel: aTopLevel = (
	| array|
	array:: anObjectMirror reflectee.
	
	(1 to: array size) do: [ :index  |
		| elem |
		elem:: (contents at: index).
		 array at: index put: (elem referencedObjectFrom: anObjectStore topLevel: aTopLevel).
	].

)
public isKindOfArrayDefinition = (
^ true
)
public withDependentObjectReferencesByIdDo: aBlock = (
	(* do nothing *)
)
) : (
)
class ChangesSerialization = (
|
	
	
|
) (
class ChangesSerializer = (
|
	handlers = List new.

|
) (
serializerFor: anObject = (
	| h |
	h:: handlers detect: [ :each | each handles: anObject].
	^h for: anObject
)
) : (
)
class ObjectHandler = (
|

|
) (
public createObjectStateNewFrom: newObjectBlock  = (

)
) : (
)
class RegularObjectHandler for: anObject = (
|
	object = anObject.
	
|
) (
createState: anObject newObjectFrom: newObjectBlock = (
	|  valuesBySelector objectMirror  enclosingObjectReference |
	valuesBySelector:: Map new.
	
	slotsIn: anObject do:  [ :selector :content |
		| objectReference |
		objectReference:: toObjectReference: content newObjectFrom: newObjectBlock .
		valuesBySelector at: selector put: objectReference.
	].

	^ valuesBySelector		
			
)
) : (
handles: anObject  = (
	^ true
)
)
public createDefaultChangesSerializer = (
	| cs|
	cs = ChangesSerializer new.
	cs addHandler:  RegularObjectHandler.
	cs addHandler:  ArrayHandler.

	
	^cs

)
) : (
)
public class ClassDefinition mixin: aMixinReference superclass: aSuperclassReference enclosingObjectReference: anEnclosingObjectReference   = ObjectDefinitionBase (
|
	mixinReference = aMixinReference.
	superclassReference = aSuperclassReference.
	enclosingObjectReference = anEnclosingObjectReference.
	
|
) (
public asGlobalReferenceUsing: objectStore = (
	^ClassDefinition 
		mixin: (mixinReference asGlobalReferenceUsing: objectStore) 
		superclass: (superclassReference asGlobalReferenceUsing: objectStore)  
		enclosingObjectReference: (enclosingObjectReference asGlobalReferenceUsing: objectStore) 
	
)
public createEmptyInstanceUsingContext: aContext topLevel: aTopLevel = (
	| 
	mixin= mixinReference referencedObjectFrom: aContext topLevel: aTopLevel. 
	superclass = superclassReference referencedObjectFrom: aContext topLevel: aTopLevel.
	eo = enclosingObjectReference referencedObjectFrom: aContext topLevel: aTopLevel.
	
	|
	(* halt. *)
	(* perform check? install? *) 

(*	(mixin printString includesSubstring: 'ToDoListSubject') ifTrue: [halt.]. *)
	^mixin applyTo: superclass withEnclosingObject: eo. 



)
public fill: anObjectMirror resolvingReferencesWith: anObjectStore topLevel: aTopLevel = (
(* do nothing) *)
)
public withDependentInitializedObjectReferencesByIdDo: aBlock = (
	mixinReference withReferencesByIdDo: aBlock.
	superclassReference withReferencesByIdDo: aBlock.
)
public withDependentObjectReferencesByIdDo: aBlock = (
	mixinReference withReferencesByIdDo: aBlock.
	superclassReference withReferencesByIdDo: aBlock.
	enclosingObjectReference withReferencesByIdDo: aBlock.	
)
) : (
)
public class ClientToServerChangeLog  withChanges: aChangeRecordsCollection withNewObjects: aNewObjectsCollection = (
|
	public versionId
	public changeRecords = aChangeRecordsCollection.
	public newObjectsDefinitions = aNewObjectsCollection.
	
|
) (
public hasNoChanges = (
	^ changeRecords isEmpty and: [ newObjectsDefinitions isEmpty].
)
public hasNoNewObjectsDefinitions = (
	^ newObjectsDefinitions isEmpty. 
)
) : (
)
public class NewObjectReference toObjectIdentifiedWith: anIdentifier  = ObjectReferenceBase (
|
	public identifier = anIdentifier.
|
) (
public asGlobalReferenceUsing: aStore = (
	 ^ ObjectReference toObjectIdentifiedWith: (aStore  guidForLocal: identifier). 
	(* ^ NewObjectReference toObjectIdentifiedWith: (aStore  guidForLocal: identifier).  *)
	
)
public existsReferencedObjectIn: aStore = (
	^ aStore containsNewObjectWithId: identifier
)
public isKindOfNewObjectReference = (
	^ true
)
public referencedObjectFrom: anObjectStore = (

	^ anObjectStore newObjectWithId: identifier.
)
public refersToNil = (
	^ false
)
public withReferencesByIdDo: aBlock  = (
	aBlock value: self value: identifier.
)
) : (
)
public class ObjectChangeRecord for: anObjectReference withChange: aChange  = (
|
	public objectReference =anObjectReference.
	public change = aChange.
|) (
public applyChangesIn: aContext usingMirror: objectMirrorClass = (
	| objectToModify objectToModifyMirror |
	objectToModify:: objectReference referencedObjectFrom: aContext topLevel: nil.
	objectToModifyMirror:: objectMirrorClass reflecting: objectToModify.
	change applyIn: aContext usingMirror: objectToModifyMirror.
	
)
public asGlobalReferenceUsing: objectStore = (

	^ class 
		for: (objectReference asGlobalReferenceUsing: objectStore) 
		withChange: (change asGlobalReferenceUsing: objectStore).
)
public changes = (
	^ change changes.
)
public isKindOfObjectChangeRecord = (
^ true
)
public refersTo: anObject in: aContext = (
	^ objectReference refersTo: anObject inContext: aContext.
)
) : (
)
public class ObjectDefinition classReference: aClassReference  withContents: contents  = ObjectDefinitionBase (
|
	public classReference = aClassReference.
	public slotsContents = contents.

|
) (
public appliedWithChange: aChange = (
	| newContents |
	newContents::  newMapFrom: slotsContents. 
	
	aChange changes keysAndValuesDo: [ :k :v  |
		newContents at: k put: v.	
	].

	^ class classReference: classReference withContents: newContents.
	
)
public asGlobalReferenceUsing: objectStore = (

	| globalClassReference globalSlotContents  | 
	
	globalClassReference::  classReference asGlobalReferenceUsing: objectStore.
	
	globalSlotContents:: Map new.
	slotsContents keysAndValuesDo: [ :key :value |   globalSlotContents at: key put: (value asGlobalReferenceUsing: objectStore)   ].	
	

	^ class classReference: globalClassReference  withContents: globalSlotContents.
)
public createEmptyInstanceUsingContext: aContext topLevel: aTopLevel = (
	^ (classReference referencedObjectFrom: aContext topLevel: aTopLevel) basicNew
)
public fill: anObjectMirror resolvingReferencesWith: anObjectStore topLevel: aTopLevel = (

	slotsContents keysAndValuesDo: [ :slotName :reference |
		anObjectMirror setSlot: slotName to: (reference referencedObjectFrom: anObjectStore topLevel: aTopLevel). 	
	
	].

(*
	anObjectMirror getClass slots do: [ :slot |
		| slotName = slot reflectee. |
		(slotsContents includesKey: slotName) ifTrue: [
			| reference = slotsContents at: slotName. |
			anObjectMirror setSlot: slotName to: (reference referencedObjectFrom: anObjectStore topLevel: aTopLevel). 
		].
		
	*)	
	

)
public isKindOfObjectDefinition = (
^ true
)
public slotNamed: aSlotName hasValue: anObject = (
	^ (slotsContents at: aSlotName) refersTo: anObject.
)
public withDependentObjectReferencesByIdDo: aBlock = (
	classReference withReferencesByIdDo: aBlock.
)
) : (
)
class ObjectDefinitionBase = (
|

|
) (
public createEmptyInstanceUsingContext: aContext topLevel: aTopLevel = (
	^ self subclassResponsibility
)
public withDependentInitializedObjectReferencesByIdDo: aBlock = (
)
public withDependentObjectReferencesByIdDo: aBlock = (
	^ self subclassResponsibility
)
) : (
)
public class ObjectDefinitionWithIdentification id: anId definition: aDefinition = (
|
	public id = anId.
	public definition = aDefinition. 
|
) (
) : (
)
public class ObjectReference toObjectIdentifiedWith: anIdentifier = ObjectReferenceBase (
|
	public identifier = anIdentifier.
|
) (
public = anotherObject = (

	^anotherObject isKindOfObjectReference and: [ identifier = anotherObject identifier].
)
public asGlobalReferenceUsing: aStore = (
	 ^  self .  
	(* ^ NewObjectReference toObjectIdentifiedWith: identifier. *)
)
public existsReferencedObjectIn: aStore = (
	^ aStore containsObjectWithGuid: identifier
)
public isKindOfObjectReference = (
	^ true
)
public referencedObjectFrom: anObjectStore topLevel: aTopLevel  = (
	^ anObjectStore objectWithGuid: identifier.
)
public refersTo: anObject  inContext: aContext  = (
	^( aContext isIdentifiable: anObject) and: 
		  [ (aContext isTracked: anObject) and:		
			[identifier = (aContext idForObject: anObject)] ]. 
)
public refersTo: anObject  inContext: aContext topLevel: aTopLevel  = (
	^refersTo: anObject inContext: aContext
)
public refersToNil = (
	^ false
)
public withReferencesByIdDo: aBlock  = (
	aBlock value: self value: identifier.
)
) : (
)
class ObjectReferenceBase = (
|

|
) (
= anotherObject = (
	subclassResponsibility
)
public withReferencesByIdDo: aBlock = (
	subclassResponsibility
)
) : (
)
public class ObjectReferenceByMessageSend receiverReference: aReference selector: aSelector  = ObjectReferenceBase (
|

	public receiverReference  = aReference.
	public selector = aSelector.
|
	
) (
public asGlobalReferenceUsing: aStore = (

	 ^  class receiverReference: (receiverReference asGlobalReferenceUsing: aStore) selector: selector.  
)
public existsReferencedObjectIn: aStore = (
	^ receiverReference existsReferencedObjectIn: aStore.
)
public isKindOfObjectReference = (
	^ true
)
public referencedObjectFrom: anObjectStore = (
	| receiver |
	receiver:: receiverReference referencedObjectFrom: anObjectStore topLevel: nil.
(*	^ (ObjectMirror reflecting: receiver) 	
					perform: selector with: {}  ifFail: [ error].
*)				
	^valueFromReceiver: receiver.			
	
					
					
)
public referencedObjectFrom: anObjectStore topLevel: topLevelObject  = (
	| receiver |
	receiver:: receiverReference referencedObjectFrom: anObjectStore topLevel: topLevelObject.
	receiver ifNil: [
		receiver:: topLevelObject.
	].

	^valueFromReceiver: receiver.		
	
)
public refersTo: anObject  inContext: aContext topLevel: aTopLevel  = (

	^(referencedObjectFrom: aContext topLevel: aTopLevel) = anObject
	
)
public refersToNil = (
	^ receiverReference isNil or: [ receiverReference refersToNil].
)
valueFromReceiver: anObject  = (
	| r |
	r:: (ObjectMirror reflecting: anObject) 	
					evaluate: selector asString.
	r isFulfilled ifFalse: [error].		
	^r result reflectee 
)
public withReferencesByIdDo: aBlock  = (
	receiverReference withReferencesByIdDo: aBlock.
)
) : (
)
public class RegularObjectChange withChanges: valuesBySlot  = (
|
	public changes = valuesBySlot.
|

	
) (
public appliedWithChange: aChange = (
	| newContents |
	newContents::  newMapFrom: changes. 
	
	aChange changes keysAndValuesDo: [ :k :v  |
		newContents at: k put: v.	
	].

	^ class withChanges: newContents.
	
)
public applyIn: aContext usingMirror: objectMirror  = (
	
	changes keysAndValuesDo: [ :slot :reference |
		| referencedObject  |
		referencedObject:: reference referencedObjectFrom: aContext topLevel: nil.
		objectMirror setSlot: slot to: referencedObject.
	].
)
public asGlobalReferenceUsing: objectStore = (

	|  changesWithGlobalReference |
	
	changesWithGlobalReference:: Map new.
	changes  keysAndValuesDo: [ :key :value |   changesWithGlobalReference at: key put: (value asGlobalReferenceUsing: objectStore)   ].	

	^ class withChanges: changesWithGlobalReference.
)
public asObjectChangeRecordForId: anId = (
	^ ObjectChangeRecord 
		for: (ObjectReference toObjectIdentifiedWith:  anId)
		withChange: self.

)
public isKindOfObjectChange = (
	^ true
)
) : (
)
public class ServerToClientChangeLog  mappingIdsWith: idsMap changeRecords: changes newObjects: newObjectsCollection versionId: aVersionId   = (
|
	public localToGlobalIds = idsMap.
	public changeRecords = changes.
	public newObjects = newObjectsCollection.
	public versionId =aVersionId.
	public rootObjectReference
|
) (
) : (
)
public class UnidentifiableObject for: aValue = ObjectReferenceBase (
|
	value = aValue.
|
) (
public = anotherObject = (

	^anotherObject isKindOfUnidentifiableObjectReference and: [  anotherObject refersTo: value ].
)
public asGlobalReferenceUsing: aStore = (
	^  self
)
public existsReferencedObjectIn:  aStore  = (
	^ true
)
public isKindOfUnidentifiableObjectReference = (
	^true 
)
public referencedObjectFrom: anObjectStore topLevel: t = (
	^ value.
)
public refersTo: anObject = (
	^  value = anObject.
)
public refersTo: anObject inContext: aContext = (
	^refersTo: anObject.
)
public refersTo: anObject inContext: aContext topLevel: aTopLevel = (
	^refersTo: anObject.
)
public refersToNil = (
	^ refersTo: nil.
)
public withReferencesByIdDo: aBlock = (
	(* do nothing *)
)
) : (
)
public classFor: anObject = (
	| mirror  |
	mirror:: ObjectMirror reflecting: anObject.
	^ mirror getClass reflectee
)
public classNameFor: anObject = (
	| mirror  |
(anObject ifNil: [aa]).
	mirror:: ObjectMirror reflecting: anObject.
	^ mirror getClass reflectee mixin name

)
public enclosingObjectFor: aClass = (
	| mirror  |

	mirror:: ClassMirror reflecting: aClass. 
	^ mirror enclosingObject reflectee

)
public enclosingObjectForClassOf: anObject = (
	| mirror  |
	mirror:: ObjectMirror reflecting: anObject.
	^ mirror getClass enclosingObject reflectee

)
public mixinNameForClass: aClass = (
	 ^aClass mixinSlot name

)
public newMapFrom: aMap = (
	| newMap |
	newMap:: Map new.
	aMap keysAndValuesDo: [ :key :val | newMap at: key put: val ].
	^ newMap
)
) : (
)
